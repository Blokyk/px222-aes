module TestCipher(testCipher) where

import Runner

import Byte
import Word

import Cipher
import Cipher.Internal.Utils

testCipher :: HasCallStack => IO ()
testCipher =
    runTests "Cipher" [
        testEncrypt, testDecrypt,
        testEncryptECB, testDecryptECB,
        testEncryptCBC, testDecryptCBC
    ]

testEncrypt :: HasCallStack => IO Bool
testEncrypt
    = newTest "Encryption: Classic" [
           (
            encrypt key128 block,
            result128
        ), (
            encrypt key192 block,
            result192
        ), (
            encrypt key256 block,
            result256
        )
    ]
    where
        block = wordsAsCipherData $ map wordFromInt [0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff]

        key128 = wordsAsCipherData $ map wordFromInt [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f]
        result128 = wordsAsCipherData $ map wordFromInt [0x69c4e0d8, 0x6a7b0430, 0xd8cdb780, 0x70b4c55a]

        key192 = wordsAsCipherData $ map wordFromInt [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617]
        result192 = wordsAsCipherData $ map wordFromInt [0xdda97ca4, 0x864cdfe0, 0x6eaf70a0, 0xec0d7191]

        key256 = wordsAsCipherData $ map wordFromInt [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f]
        result256 = wordsAsCipherData $ map wordFromInt [0x8ea2b7ca, 0x516745bf, 0xeafc4990, 0x4b496089]

testDecrypt :: HasCallStack => IO Bool
testDecrypt
    = newTest "Decryption: Classic" [
        (
            decrypt key128 (encrypt key128 block),
            block
        ), (
            decrypt key192 (encrypt key192 block),
            block
        ), (
            decrypt key256 (encrypt key256 block),
            block
        )
    ]
    where
        block = wordsAsCipherData $ map wordFromInt [0x3243f6a8, 0x885a308d, 0x313198a2, 0xe0370734]
        key128 = wordsAsCipherData $ map wordFromInt [0x2b7e1516, 0x28aed2a6, 0xabf71588, 0x09cf4f3c]
        key192 = wordsAsCipherData $ map wordFromInt [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617]
        key256 = wordsAsCipherData $ map wordFromInt [0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f, 0x10111213, 0x14151617, 0x18191a1b, 0x1c1d1e1f]

testEncryptECB :: HasCallStack => IO Bool
testEncryptECB
    = newTest "Encryption: ECB" [
           (
            encryptECB key (block1 ++ block2),
            encrypt key block1 ++ encrypt key block2
        )
    ]
    where
        key = map byteFromInt [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]
        block1 = map byteFromInt [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
        block2 = map byteFromInt [0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87, 0x78, 0x69, 0x5a, 0x4b, 0x3c, 0x2d, 0x1e, 0x0f]

testDecryptECB :: HasCallStack => IO Bool
testDecryptECB
    = newTest "Decryption: ECB" [
           (
            decryptECB key (encryptECB key (block1 ++ block2)),
            block1 ++ block2
        )
    ]
    where
        key = map byteFromInt [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]
        block1 = map byteFromInt [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
        block2 = map byteFromInt [0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87, 0x78, 0x69, 0x5a, 0x4b, 0x3c, 0x2d, 0x1e, 0x0f]

testEncryptCBC :: HasCallStack => IO Bool
testEncryptCBC
    = newTest "Encryption: CBC" [
           (
            encryptCBC key (block1 ++ block2),
            let
                e1 = encrypt key (key `xorBytes` block1)
                in e1 ++ encrypt key (e1 `xorBytes` block2)
        )
    ]
    where
        key = map byteFromInt [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]
        block1 = map byteFromInt [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
        block2 = map byteFromInt [0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87, 0x78, 0x69, 0x5a, 0x4b, 0x3c, 0x2d, 0x1e, 0x0f]

testDecryptCBC :: HasCallStack => IO Bool
testDecryptCBC
    = newTest "Decryption: CBC" [
           (
            decryptCBC key (encryptCBC key (block1 ++ block2)),
            block1 ++ block2
        )
    ]
    where
        key = map byteFromInt [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]
        block1 = map byteFromInt [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
        block2 = map byteFromInt [0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87, 0x78, 0x69, 0x5a, 0x4b, 0x3c, 0x2d, 0x1e, 0x0f]
